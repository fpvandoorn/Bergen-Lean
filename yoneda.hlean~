--The following special case of the Yoneda lemma:
--If A -> X ~= B -> X for all X, then A ~= B
import types.equiv
import types.pointed

open pointed eq equiv is_equiv function

--set_option pp.all true

definition inv_inv {A B : Type} (e : A ≃ B) : e⁻¹⁻¹ = e :=
  begin
    apply eq_of_homotopy,
    intro a,
    exact equiv.to_inv_eq_of_eq _ (symm (to_left_inv e a))
  end
  
structure typeclass :=
  (data : Type → Type)

namespace typeclass
  structure obj.{u v} (C : typeclass.{u v}) : Type.{max (u+1) v} :=
    (U : Type.{u})
    (struct : data C U)

  attribute obj.U [coercion]

end typeclass open typeclass

-- A "concrete infinity-category", a subcategory of the inf-category of types
-- An object consists of a type plus some data
-- The arrows are the 'good' maps
structure cCat.{u v} extends CC:typeclass.{u v} : Type.{(max u v)+1} :=
  (good : Π {A B : obj CC} , (A → B) → Type.{u})
  (idwd : Π (A : obj CC), good (λ (x : A) , x))
  (compwd : Π {A B C : obj CC} (g : B → C) (f : A → B), good g → good f → good (g ∘ f))
  (coh_unitr : Π {A B : obj CC} (g : A → B) (p : good g) ,
    compwd g (λ x , x) p (idwd A) = p)
namespace cCat
  variables {CC : cCat}

  structure arr (A B : obj CC) :=
    (to_fun : A → B)
    (wd : good CC to_fun)

  infix ` →* `:30 := pmap

  attribute arr.to_fun [coercion]

  definition arr_inj {A B : obj CC} {f g : A → B} {p : good CC f} {q : good CC g}
    (f_is_g : f = g) (p_is_q : p =[ f_is_g ] q) : arr.mk f p = arr.mk g q := 
    begin
      induction f_is_g,
      apply congr_arg _ _ (arr.mk f),
      apply eq_of_pathover_idp p_is_q
    end

  definition arr_eta {A B : obj CC} (f : arr A B) : f = arr.mk (arr.to_fun f) (arr.wd f) :=
    begin
      induction f,
      reflexivity
    end

  definition arr_inj' {A B : obj CC} {f g : arr A B} (p : arr.to_fun f = arr.to_fun g) (q : arr.wd f =[ p ] arr.wd g) : f = g :=
    begin
      transitivity _,
      apply arr_eta,
      transitivity _,
      apply arr_inj,
      exact q,
      symmetry,
      exact arr_eta g
    end

  definition id (A : obj CC) : arr A A :=
    arr.mk (λ x , x) (idwd CC A)

  definition comp {A B C : obj CC} (g : arr B C) (f : arr A B) : arr A C :=
    begin
      apply arr.mk (g ∘ f),
      apply compwd CC g f (arr.wd g) (arr.wd f)
    end

  infix ` ∘* `:50 := comp

  definition unitr {A B : obj CC} (f : arr A B) : f ∘* id A = f :=
    begin
      fapply arr_inj',
      reflexivity,
      apply pathover_idp_of_eq,
      apply coh_unitr
    end

  structure cequiv (A B : obj CC) extends e:equiv A B, arr A B :=
    (wd_inv : good CC e⁻¹ᵉ)

  infix ` ≃* `:25 := cequiv

  protected definition cequiv.symm [symm] [constructor] {A B : obj CC} (f : A ≃* B) : B ≃* A :=
    begin
      apply cequiv.mk,
      exact cequiv.wd_inv f,
      esimp,
      apply transport (good CC),
      rotate 1,
      exact cequiv.wd f,
      symmetry,
      refine inv_inv _
    end
end cCat open cCat

--Closed concrete infinity-category
structure ccCat.{u v} extends CC:cCat.{u v} : Type.{(max u v)+1} :=
  (closed : Π {A B : obj CC} , data (arr A B))

namespace ccCat
  open function
  variables {C : ccCat}

  definition hom (A B : obj C) : obj C := obj.mk (arr A B) (closed C)

  definition deYonedify.{u v w} {C : ccCat.{u v}} {A B : obj C} (f : Π X, @cequiv.{u v} C (hom A X) (hom B X)) : B → A := 
    begin
      refine @arr.to_fun C _ _ _,
      apply equiv.to_fun (f A),
      apply id
    end

  definition yoneda {A B : obj C} 
    (e : Π (X : obj C) , @cequiv C (hom A X) (hom B X)) 
    (enat : Π {X Y} (f : arr X Y) (g : arr A X), f ∘ e X g = e Y (f ∘* g))
    : 
    @cequiv C A B :=
    begin
      fapply cequiv.mk,
      {
        apply deYonedify,
        intro X,
        apply cequiv.symm,
        exact (e X)
      },
      {
        fapply is_equiv.mk,
        exact deYonedify e,
        {
          apply congr_fun,
          transitivity _,
          apply enat (cequiv.symm (e B) (id B)) (id A),
          { 
            transitivity _,
            {
              apply congr_arg _ _ arr.to_fun,
              apply congr_arg _ _ (e B),
              apply unitr
            },
            {
              symmetry,
              refine congr_arg (id B) _ arr.to_fun _,
              apply to_eq_of_inv_eq (e B),
              reflexivity
            }
          }
        },
        {
        },
        {
        }
      },
      {
      }
    end

definition pTypeC.{u} : ccCat.{u u u} :=
  begin
    fapply mk,
    {
      fapply cCat.mk, 
      {
        exact λ A , A
      },
      {
        intro A B f,
        exact f (obj.struct A) = obj.struct B
      },
      {
        intro A,
        exact refl _
      }
    },
    {
      intro A B,
      apply arr.mk,
      exact refl _
    }
  end

namespace pointed

  definition yoneda.{u} {A B : pType.{u}} (e : Π (X : pType.{u}) , (ppmap A X) ≃* (ppmap B X)) : A ≃* B :=
    begin
      fapply pequiv_of_equiv,
      { 
        fapply equiv.mk,
        { 
          apply ccCat.deYonedify pTypeC, 
          intro X,
          apply to_equiv,
          apply pequiv.symm,
          exact (e X)
        },
        { fapply is_equiv.mk, 
          {
            apply Yonedable.deYonedify pTypeY,
            intro X,
            apply to_equiv,
            exact (e X)
          },
          {
          },
          {
          },
          {
          }
        }
      },
      { 
      }
    end

end pointed
